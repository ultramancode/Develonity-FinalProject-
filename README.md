# Develonity
> `Developer` + `Community` = `Develonity` 
>
- **입문 & 주니어 & 시니어 개발자 모두에게 가치 있는 커뮤니티를 만들고자 했습니다.**
- Q&A 게시판 활동(답변)을 통해 `Gift Point`를 쌓을 수 있습니다. 해당 포인트로 `Gift Card` 를 살 수 있습니다.
- 커뮤니티 활동을 통해 `Respect Point` 가 쌓이게 되고, 이를 통해 등급을 올릴 수 있습니다.

<br>

![브로셔메인페이지](https://user-images.githubusercontent.com/116135174/224562613-25b15240-4157-4a6c-a908-69a7a942bf95.PNG)

팀원 소개 👨‍👩‍👧‍👦
---



| [김태웅](https://github.com/ultramancode) | [이솔](https://github.com/LEESOLL) | [조성현](https://github.com/dangddoong) | [배지호](https://github.com/2Luda) | [송성원](https://github.com/SungWonSong) |
| :---:| :---: | :---: | :---: | :---: |
| <img src="https://taewoong-test.s3.ap-northeast-2.amazonaws.com/pp/KakaoTalk_20230313_164601238_01.jpg" width="135" height="160"> | <img src="https://taewoong-test.s3.ap-northeast-2.amazonaws.com/pp/KakaoTalk_20230313_163720357.jpg" width="135" height="160">  | <img src="https://taewoong-test.s3.ap-northeast-2.amazonaws.com/pp/KakaoTalk_20230313_163501658.jpg" width="135" height="160"> | <img src="https://taewoong-test.s3.ap-northeast-2.amazonaws.com/pp/KakaoTalk_20230313_164603334.jpg" width="135" height="160"> | <img src="https://taewoong-test.s3.ap-northeast-2.amazonaws.com/pp/KakaoTalk_20230313_163841527.jpg" width="135" height="160"> |
| [<img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white">](https://github.com/dangddoong) | [<img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white">](https://github.com/LEESOLL) | [<img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white">](https://github.com/ultramancode) | [<img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white">](https://github.com/2Luda) | [<img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white">](https://github.com/SungWonSong) | 




서비스 아키텍쳐📖
---

![서비스아키텍처](https://user-images.githubusercontent.com/116135174/224563517-e0caea58-799d-481c-958c-0c505306c922.png)


기술 스택 💻
---
Front-End 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f48544d4c2d4533344632363f7374796c653d666c6174266c6f676f3d68746d6c35266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563690-49f7978a-08cc-444e-b68d-25f8f3dca096.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4353532d3135373242363f7374796c653d666c6174266c6f676f3d63737333266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563708-a893b2d2-3a9f-437c-90f9-2fb1e4b5d59c.svg)
<img src="https://img.shields.io/badge/Visual Studio-5C2D91?style=flat&logo=Visual Studio&logoColor=white">
<img src="https://img.shields.io/badge/jQuery-0769AD?style=flat&logo=jQuery&logoColor=white">
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat&logo=JavaScript&logoColor=white">

Back-End 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a6176612d3030373339363f7374796c653d666c6174266c6f676f3d4f70656e4a444b266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563807-67c19880-4cf0-4dff-864e-8c0b5e334d26.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f426f6f742d3644423333463f7374796c653d666c6174266c6f676f3d737072696e67626f6f74266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563810-e6bf9887-21e0-4335-b363-4a06d47ff332.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e672d3644423333463f7374796c653d666c6174266c6f676f3d537072696e67266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563819-60e7b43b-41d8-48c4-9ff5-8d920274f05e.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f446174615f4a50412d3644423333463f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563822-34f5705d-1a3a-40c2-92cb-53476f64019f.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f53656375726974792d3644423333463f7374796c653d666c6174266c6f676f3d737072696e677365637572697479266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563832-48210ac1-d1a8-4712-8f58-d2bbeab82e0a.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f52656469732d4443333832443f7374796c653d666c6174266c6f676f3d7265646973266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563838-7056f1cc-45dd-4468-8f62-a28f93c0bc7c.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f517565727944736c2d3430414546303f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563844-c776b411-7082-4d18-ac10-16f81ebffbe9.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a57542d4139323235433f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563850-b63732e7-71f6-4f82-89d5-f8bddc791feb.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f477261646c652d3032333033413f7374796c653d666c6174266c6f676f3d677261646c65266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563860-f3344686-f5e5-472a-88d1-2f47a136a82a.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f48696265726e6174652d3539363636433f7374796c653d666c6174266c6f676f3d48696265726e617465266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563866-331e0ce4-ee26-444c-9660-89ca9d191dab.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f506f73746d616e2d4646364333373f7374796c653d666c6174266c6f676f3d506f73746d616e266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563871-9ccb51f3-1be2-45d0-ab1f-e4d792e049dd.svg)
<img src="https://img.shields.io/badge/JUnit5-25A162?style=flat&logo=JUnit5&logoColor=white">
<img src="https://img.shields.io/badge/MySQL-4479A1?style=flat&logo=MySQL&logoColor=white">

Server 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f53332d3536394133313f7374796c653d666c6174266c6f676f3d616d617a6f6e7333266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563965-0407b444-b4dc-4fcd-8060-5c0cac870f57.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f4543322d4646393930303f7374796c653d666c6174266c6f676f3d616d617a6f6e656332266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563977-98fc9d8d-1820-4881-aa81-e593585c570f.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f5244532d3532374646463f7374796c653d666c6174266c6f676f3d616d617a6f6e726473266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224565820-02995aae-65b8-4bdb-ad84-06500f32741d.svg)


Etc

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4769746875622d3138313731373f7374796c653d666c6174266c6f676f3d676974687562266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564009-4100e123-0818-44f8-acba-bc5d0540d66c.svg)
<img src="https://img.shields.io/badge/GitHub Actions-2088FF?style=flat&logo=GitHub Actions&logoColor=white">
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f536c61636b2d3441313534423f7374796c653d666c6174266c6f676f3d736c61636b266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564017-f1c15951-64d8-4352-866a-12ca984e6424.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4e6f74696f6e2d3030303030303f7374796c653d666c6174266c6f676f3d6e6f74696f6e266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564022-db759b69-a20d-4ec6-9bdb-7fa96bf36d69.svg)
<img src="https://img.shields.io/badge/Jira-0052CC?style=flat&logo=Jira&logoColor=white">

API 문서(Postman Publish Documentation)📋
---
[API 문서](https://documenter.getpostman.com/view/24836890/2s93JqRjo6#284b7458-f36f-4878-a3ce-378b21d70cbe)

기술적 의사결정 👓
---
<details>
<summary>Session vs Token(JWT)</summary>
<br>

- 보안 vs 효율&확장성
- 서비스의 특성상(커뮤니티) 보안적으로 매우 민감한 주제는 아니라고 판단<br>
- HTTP의 비상태성(Stateless)를 그대로 활용할 수 있고, 따라서 높은 확장성을 가질 수 있는 Token방식을 채택

<br>

>**문제점** <br>
>- 보안 이슈 발생
><br>

>**해결책**
>- refresh token을 도입하여 access token의 유효기간을 짧게 가져감
>- RTR(refresh token rotation)을 도입하여 refresh token 탈취 시 문제점 보완

<details><summary>➕access token과 refresh token이 모두 탈취 당했을 경우에 대한 고민🤷</summary>
<br>

📋 참고자료
- [네이버 토큰 갱신 방법[grant_type, client id를 같이 보내는 방식]](https://developers.naver.com/docs/login/devguide/devguide.md#5-1-2-%EA%B0%B1%EC%8B%A0-%ED%86%A0%ED%81%B0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC:~:text=Authorization%3A%20Bearer%20ACCESS_TOKEN-,5.1.2%20%EA%B0%B1%EC%8B%A0%20%ED%86%A0%ED%81%B0%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC,-%EC%A0%91%EA%B7%BC%20%ED%86%A0%ED%81%B0%EC%9D%80%20%EC%A0%91%EA%B7%BC)

- [카카오 토큰 갱신 방법](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#refresh-%20%20%20%20%20%20%20%20%20token:~:text=%3A1234%0A%7D-,%ED%86%A0%ED%81%B0%20%EA%B0%B1%EC%8B%A0%ED%95%98%EA%B8%B0,-%EA%B8%B0%EB%B3%B8%20%EC%A0%95%EB%B3%B4)

<br>

**📌 현재 프로젝트에서 대응 가능한 방법들**<br>
- 사용자가 서비스를 지속적으로 이용중인 상황<br>
   - RTR(refresh token rotation)을 적용하고 access token의 유효시간을 30분으로 짧게 설정<br>
   - `[reissue 실패 → 재로그인 → 탈취된 refresh token 무효화]` 가능<br>
  
- 특정 상황이 발생하여 회원 다수의 token이 탈취된 경우
   - 30분여 서비스 점검 실시(access token 유효기간 만료를 위함) 및 
    `redis(refresh token 저장소)를 재가동` 하는 방법 고려. (서비스 점검기간동안 보안적인 대처도 병행)<br>
   
- 현재 계정정보 접근, 회원탈퇴 등 민감한 서비스들에는 `패스워드 재검증 로직`을 포함하고 있으므로 개인정보 유출, 금전적 피해가 발생 가능한 경우는 예방하고 있다.
</details>

</details><br>
<details>
<summary>Redis - Token 저장소로 Redis를 선정한 이유</summary><br><br>

>- Key(LoginId)-Value(Refresh Token) 외의 다른 필드가 필요하지 않음
>- 인메모리 데이터 저장소이므로 빠르게 접근 가능
>- Refresh Token은 영구적으로 저장될 필요가 없으며 Redis의 TTL(Time To Live) 지정을 통해 만료 기간을 쉽게 설정 가능
>- Redis의 데이터가 날아가더라도 로그아웃되는 정도라서 덜 치명적임
>- RDB의 스냅샷 백업 기능을 활용하여 디스크 저장 가능, 추후 더욱 안정성 있는 백업 기능을 원하면 AOF 방식으로 변경 가능
>- 저장된 데이터의 개수와 무관하게 O(1) 의 수행시간을 가짐
>- 저장된 모든 token을 조회할 일이 없어, 싱글 스레드의 단점이 부각 될 상황이 없음
<br><br>

### **인메모리 데이터 저장소 중 왜 Redis를 선택했는가?(Redis vs Memcached)**

인메모리 데이터 저장소로 성능과 대중성을 갖춘 것은 **Redis**와 **Memcached**가 있음

두 저장소 중에 무엇을 사용할까 고민했고, 아래와 같은 이유로 **Redis를 선택**하게 됨

>- 문자열만 지원하는 Memcached와 달리 Redis는 문자열 및 List, Set 등의 다양한 데이터 타입을 지원해서 확장성이 큼
>- Redis는 RDB방식과 AOF 방식으로 디스크 백업 기능을 지원함
>- Redis가 더 다양한 기능을 제공하는데 성능은 Memcached와 비슷하고, 문서화된 자료도 많으며 Spring Boot에서 Redis를 위한 API를 지원함
    
    →러닝커브도 낮고, 유지 보수성 측면에서 유리하다고 판단
    
<br><br>
</details>

<details>
<summary>Admin과 User 분리(Factory Pattern)</summary><br>


**기존 방식**

- 동일한 User Entity에서 `Role Enum` 으로 Admin과 User를 구분
- 동일한 security filter와  Authentication Service를 사용

>**문제점**
><br>
>- 근본적으로 User와 Admin의 생명주기가 다름
>- User와 Admin의 역할과 그에 따른 기능들이 다름
>- User와 Admin의 인증과정을 분리할 수 없음.
><br>

>**해결**
><br>
>- Entity 및 Package 분리
>- security filter와  Authentication Service 분리
>- Authentication Service에 `팩토리 패턴` 적용하여 OCP 원칙을 지키고자 노력
</details>

<details>
<summary>게시글 JPA 상속 관계 매핑(단일 테이블 전략)</summary><br>

<br>

>**JPA는 DB와 객체를 매핑해주는 자바 진영의 ORM 기술 표준이지만 객체의 상속 관계와 정확하게 일치하는 DB모델링은 존재하지 않음**
>
>**따라서 차선책으로 상속 관계와 비교적 유사한 **슈퍼타입-서브타입** 모델링 기법으로 DB를 상속 객체에 매핑**
>
>**슈퍼타입-서브타입 논리모델을 실제 DB 물리모델로 구현하는 방법으로 3가지 전략 중 ➕단일 테이블 전략➕을 사용**
>
<br>

📌 **단일 테이블 전략의 장점**

- 조인이 필요 없으므로 조회 성능이 빠름
- 조회 쿼리가 단순<br><br>

📌 **단일 테이블의 단점**

- 하위 엔티티의 필드값은 모두 Null을 허용
- 하나의 테이블에 칼럼이 많아져 복잡<br><br>

📌 **단일 테이블 전략을** **선택한 이유**

>- 현재 게시글의 필드값을 최대한 적게 가져가는 방식을 사용 중이기 때문에
><br>테이블 칼럼 수가 적기 때문에 단일 테이블 전략을 사용하더라도 복잡해지지 않음<br>
>
>- 비록 데이터베이스에는 Null값을 허용하더라도 실제 객체가 Null값을 가지고 있는 것은 아님<br>
>
>- 만약 단일 테이블 전략이 아니라 각자 테이블을 가지는 조인 전략과 같은 방식을 사용했다면
><br>Null값은 들어가지 않지만 조회 쿼리가 복잡해지고 INSERT QUERY를 2번 실행해야 하기 때문에
><br>단일 테이블 전략을 사용하기로 결정
<br>
</details>

<details>
<summary>ID를 활용한 간접참조 방식 설계</summary><br>


>
>
>- **직접 참조** : Entity 클래스를 설계할 때 @OneToOne, @OneToMany와 같은 어노테이션을 써서 Entity 간에 연관 매핑하는 것
>
>- **간접 참조** : 객체를 직접 참조하지 않고, 식별값을 이용하는 것
>
>
<br>

📌 **직접 참조 방식의 단점**
- 의존 관계 형성
- 연관 관계 맺은 객체를 편하게 탐색할 수 있고 바뀌길 원하지 않는 참조 객체의 값이 손쉽게 바뀔 가능성 존재(직접 참조는 편한만큼 위험)
   - 예를 들어 Board Entity안에 user라는 변수가 있다면 Board를 다룰 때 User를 변경할 수 있는 가능성과 여러 실수의 가능성이 존재
   - 즉 User 라는 Entity 자체를 날것으로 가져오게 되면, Entity 가 오염이 될 수 도 있음
   <br> -> setter 를 통해서든, 도메인 서비스를 통해서든 어떤 일이 벌어질 수 있는 가능성을 열어둔 것
<br>

📌**결론**

>User Entity도 안전하게 보호가 되고, Board Entity에만 집중할 수 있는 방법으로 **간접 참조** 방식을 이용하는 것이 나을 것이라고 판단,
>
>간접 참조를 하면 의존 관계가 형성되지 않아서 추후 시스템을 확장할 때도 유리하기 때문에 
>
>**간접 참조 방식을 이용해서 설계**
<br>
</details>

<details>
<summary>이미지 서버로 AWS S3 선정한 이유</summary><br>


📌 **이미지 서버의 필요성**

>만약 스프링 서버의 멀티파트 파일로 이미지를 받아서 DB에 저장하는 방식을 이용 한다면<br>
>서버 여러대 사용 시, 특정 서버에만 이미지가 존재하게 될 수 있음<br>
>따라서 별도의 이미지 서버를 둘 필요성을 느낌



📌 **S3를 이미지 서버로 선유한 이유**

>커뮤니티 사이트처럼 서버에 많은 미디어 파일을 저장해야 하는 경우<br> 
>EC2와 EBS만을 사용해서 저장을 하게 되면 용량에 따른 과금도 부담되고 (비용적인 문제, S3는 사용한 만큼만 비용 지불)<br>
>저장소를 구축해서 관리하는 것에도 문제 존재(성능 문제)
>
>하지만 S3를 사용하면 S3 한 곳에 모든 미디어 파일을 저장할 수 있고<br>  
>비용적인 문제도 EC2와 EBS만을 사용해서 구축하는 것보다 훨씬 저렴하며<br>
>구축 후 확장이나 축소와 같은 DB를 관리하는 것에도 용이하다는 장점이 있어 사용
>
>
>> 📖 S3와 EBS 중 S3를 선택한 이유
>>
>>- S3가 더 저렴함
>>- EBS는반드시 하나의 인스턴스에서만 접근 할 수 있음
>>-> 여러 Application이 하나의 EBS에 담겨있는 데이터에 동시 접근 불가능
>>- 생성 전에 반드시 그 크기를 지정해주어야 함
>>- 신청한 용량 중, 쓰지 않는 부분에 불필요한 cost를 내야함
>>- 쌓이는 데이터가 신청한 용량을 넘어서게 되는 경우, 대용량에 새로운 volume을 신청하여 데이터를 옮기고, 기존에 volume을 반납해야하는 번거로움이 생김
>>
>>>**S3는 사용한 만큼만 비용을 지불하고, 무한대로 확장이 가능하며, EBS와는 다르게**
>>>**여러개의 Application이 동시에 접근할 수 있다는 장점이 있으므로 S3을 선택함**

<img width="1000" alt="스크린샷_2023-03-10_오후_8 19 32" src="https://user-images.githubusercontent.com/116135174/224602116-94870db8-6d7b-42aa-8860-4e5620d2945a.png">
</details>
</details>

트러블 슈팅 🎈
---
<details>
<summary>이미지 업로드 성능 개선</summary><br>

<br>

### 이미지 업로드 방법을 **Pre-signed URL 방식으로 변경(성능 개선율 : 165%)**

---

### **기존 업로드 방식(클라이언트 → 서버 → AWS S3 Bucket)**

 **:** `클라이언트`에서 서버로 파일을 전달하고 `서버`에서 `AWS S3 Bucket`에 업로드

![1](https://user-images.githubusercontent.com/116135174/232500121-be4db4f0-d79d-49d3-9064-37978b63f4d4.png)

**기존 방식의 단점**

- 파일 업로드 시,  `클라이언트`-> `서버`-> `AWS S3 Bucket` 의 파일 전달 흐름을 가짐
- 저장하지도 않을 파일들이 서버를 통해가면서 불필요한 서버 리소스 낭비가 발생
- 또한 과도한 업로드 작업이 생기면 서버에 과부하가 걸리게 되고 서버를 거쳐 가는 지연시간이 생기게 됨

→ 위 방법들의 단점을 보완하기 위해 Pre-signed URL 기능을 사용하여 성능을 개선

---

### 개선 후 **Presigned Url 방식(클라이언트 → AWS S3 Bucket)**

![2](https://user-images.githubusercontent.com/116135174/232500147-370d5f60-ef45-498b-9b58-885d9bb5b205.png)


- **PreSignedURL을 이용한 `클라이언트` -> `AWS S3 Bucket` 업로드**

- **업로드 순서**
    
    1.클라이언트가 서버한테 이미지 업로드 요청(클라이언트 → 서버)
    
    2.서버는 AWS에게 PutObject 방식의 Presigned url 발급 요청 (서버 → AWS S3)
    
    3.AWS에서 서버로 Presigned Url 발급(AWS S3 → 서버)
    
    4.서버에서 클라이언트로 Presigned Url 전달(서버 → 클라이언트)
    
    5.클라이언트가 Presigned Url 통해서 이미지 파일 업로드 (클라이언트 → AWS S3)
    

**효과**

- 서버의 역할이 파일 업로드를 처리하는 것에서 문자열을 주고받는 식으로 바뀌었기 때문에 프로세스가 훨씬 가벼워짐

---

### 실행 시간 차이

<aside>
💡 

**성능개선율 : 165%**

 : **(361 - 136) / 136 = 1.654**

* 개선 전 : 361ms
* 개선 후 : 136ms

</aside>

---

### **기존 이미지 업로드 방식(개선 전)**

![3](https://user-images.githubusercontent.com/116135174/232500187-a37f5c6d-9a09-4c98-bb7c-b4192b154d77.png)

![4](https://user-images.githubusercontent.com/116135174/232500215-74489f88-c194-4bc9-9bc0-c293e11602ab.png)



이미지 업로드 포함 글 작성 시간 -> 381 ms

이미지 업로드 포함하지 않은  글 작성 시간 -> 20 ms

**→ 기존 방식의 이미지 업로드 실행 시간 = 361 ms**

---

### PreSigned Url 이미지 업로드 방식(개선 후)

![5](https://user-images.githubusercontent.com/116135174/232500246-ccf131d0-6579-4b0d-be6a-e75734d978ae.png)

![6](https://user-images.githubusercontent.com/116135174/232500260-9722f9a8-7a7a-4a8f-8ccf-eb12640f4d4b.png)



Put PreSigned Url 요청 -> 18 ms

요청 받은 Url로 이미지 업로드 -> 118 ms

**→ PreSignued Url 방식의 이미지 업로드 실행 시간 = 136 ms**

</details>
<details>
<summary>QueryDSL</summary><br>

<br>

### QueryDSL을 활용한 검색 및 조회 기능으로 성능 개선(성능 개선율 : 160%)

---
<br>

### **기존 방식(Spring Data JPA 메소드 활용)**

![기존검색방식](https://user-images.githubusercontent.com/116135174/232498456-7b886b43-fd03-4cd9-92ab-4fa9d184d5ae.png)

- `Spring Data Jpa`를 이용해서 여러 조건의 검색 방식을 구현하기 위해서는 위와 비슷한 메소드들을 **여러 개 작성** 해줘야 하며, 그 방식도 제한적이고 쿼리 성능도 비효율적

### 개선 후 **QueryDSL 활용 방식**

![quer3](https://user-images.githubusercontent.com/116135174/232498573-366263df-1044-4daa-9970-461c8a18585c.png)
![수정방식](https://user-images.githubusercontent.com/116135174/232498617-40c31e00-a940-47e8-9ab7-43ef992e9df0.png)

<br>

- QueryDSL을 활용, 동적 쿼리를 작성해서 한 개 메소드로 여러 검색 및 정렬 조건을 구현
    - where()에 BooleanExpression을 사용해서 한 개의 메소드로 여러 검색 조건을 활용
    - OrderSpecifier를 이용하여 동적 쿼리로 여러 정렬 기능을 활용
- Projection을 사용해서 **Entity 전체를 가져오는 것이 아니라 Select 절에서 원하는 컬럼만 조회하도록 지정함**

<br>

**📌 JPQL 이 아닌 QueryDSL을 사용한 이유 :** 

 동적 쿼리 작성이 용이하며,  JPQL은 문법 오류를 컴파일 시점에서 잡아주지 않는다는 치명적 단점이 존재함

---

### **실행 시간 차이**

<aside>
💡 

**성능개선율 : 160%**

 : **(26 - 10) / 10 = 1.6**

* 개선 전 : 26ms
* 개선 후 : 10ms

</aside>

---

### 기존 JPA Repository 메소드 활용한 조회 방식

![image](https://user-images.githubusercontent.com/116135174/232498740-eb9d7851-c700-4508-aa90-2db0e1fc5ea2.png)

**실행 시간 : 26ms**


### QueryDsl 활용한 조회 방식

![imagef](https://user-images.githubusercontent.com/116135174/232498773-802817c6-0ed4-457a-91fe-e3bae7b9aa15.png)


**실행 시간 : 10ms**

</details>
<details>
<summary>Redis를 활용한 Cache</summary><br>
<br>

### Redis를 활용한 Cache기능으로 전체 유저 조회 기능 성능 개선(성능 개선율 : 200%) ###

---

<br>

![redisCache](https://user-images.githubusercontent.com/116135174/232497433-f78e73e0-1436-4ca9-921e-04ae872f9cb0.png)

### Redis Cache 사용

- 사용자가 늘어남에 따라 DB에 부하가 가해지기 시작한다.
- 이 부하를 줄이기 위해 한 번 읽어온 데이터를 저장하고 
다시 요청하는 경우 빠르게 결과 값을 받을 수 있도록 함 (캐싱)
- 가장 먼저 캐시에 데이터가 있는지 확인 → 데이터가 있으면 캐시 데이터 사용
- 데이터가 없으면 실제 DB데이터 사용 → DB데이터를 캐시에 저장

---

### **실행 시간 차이**

<aside>
💡 

**성능개선율 : 200%**

 : **(32 - 16) / 16 = 2**

* 개선 전 : 32ms
* 개선 후 : 16ms

</aside>

---
### 기존 조회 방식

![캐시전32ms](https://user-images.githubusercontent.com/116135174/232497569-6858bd78-1eb3-44b2-8872-44476b0b3e7f.png)

* 실행시간 : 32ms

### Cache 적용 후 조회 방식

![캐시후16ms](https://user-images.githubusercontent.com/116135174/232497588-321e5dd5-a03b-42ac-8a01-6fc7cfc3efe7.png)

* 실행시간 : 16ms
</details>
<details>
<summary>Redis를 활용한 RTR(Refresh Token Rotation) 및 AccessToken BlackList 기능</summary><br>

<br>

### Redis를 활용하여 Refresh**Token 저장, RTR(RefreshTokenRotation) 방식 사용 및 로그아웃 시 AccessToken을 BlackList로 저장**

---


### **기존 JWT(JSON Web Token)의 문제점**

- 한번 만들어진 토큰을 제어할 수 없고, 이를 위해 만료 시간을 짧게 하면 잦은 로그인이 필요해짐
- 토큰을 지울 수 없으므 로그아웃에 문제가 있다.

### **보완책**

- **Refresh Token 기능 추가**
    - Refresh Token을 도입하여 Access Token의 만료 시간을 짧게 해도 잦은 로그인 문제가 발생하지 않도록 함 (AccessToken 30분, RefreshToken 2주일로 설정)
    
![1](https://user-images.githubusercontent.com/116135174/232501172-24995d65-c508-4f93-a056-0c16d59d528e.png)

    

- **Refresh Token이 탈취당할 경우를 대비한 RTR(Refresh Token Rotation) 기능 추가**
    - 로그인과 리이슈 할 때마다 유효한 Refresh Token 생성, Redis에 저장 및 비교 과정 거침

![2](https://user-images.githubusercontent.com/116135174/232501190-bdfdc723-37fd-4bcd-b8b8-133e53c77c56.png)


- **Access Token을 Black List로 저장하면서 로그아웃 기능 구현**
    - 로그아웃 시, Redis에서 RefreshToken을 삭제하고, AccessToken을 Black List로 저장하여 Filter 단계에서 거름

![3](https://user-images.githubusercontent.com/116135174/232501219-a604029f-fb76-483e-88df-589924011fcc.png)


![4](https://user-images.githubusercontent.com/116135174/232501293-44790174-a0a3-4f58-b416-25a280cb391a.png)


</details>
